\section{Algoritmo Exacto}
De acuerdo a lo ya explicado en el inciso \ref{caballitos}, podemos establecer una analog\'ia con este problema y ``El se\~nor de los caballos''. Por lo tanto, la metodolog\'ia empleada para la implementaci\'on del algoritmo exacto tambi\'en fue la de \emph{Backtracking}.\\

De este modo, nos vemos obligados a recorrer inteligentemente todos los conjuntos dentro del conjunto de partes del total de nodos $V$. Mediante el backtracking podemos realizar podas y estrategias para saltear algunas ramas de decisi\'on donde se predice que no se va a poder encontrar la soluci\'on \'optima all\'i.


\subsection{Explicaci\'on y mejoras}
%Explicar detalladamente el algoritmo implementado. Elaborar podas y estrategias que permitan mejorar los tiempos de resolucion.

Nuestro algoritmo recorre ordenadamente el conjunto de partes de V y por cada uno de ellos verifica que cumpla la funci\'on  \texttt{esIndependienteMaximal()}. La misma devuelve 0 si es falso, la cantidad de nodos en el conjunto en caso contrario.

Es decir, se itera sobre los nodos y se pide el minimo conjunto independiente maximal considerando el nodo actual presente y ausente.\\

En una variable se acumula la soluci\'on \'optima hasta el momento, la cual se actualiza cuando se encuentra un nuevo conjunto independiente maximal que tiene un cardinal menor al \'optimo actual. En ella va a quedar la soluci\'on buscada luego de correr el algoritmo.\\

Las podas que implementamos fueron \textcolor{red}{... completar}

Y las estrategias fueron \textcolor{red}{... completar}\\

Poner el pseudocodigo...

\begin{algorithm}[h!]
\caption{algoritmo exacto}

\textit{unsigned int} \textbf{calcularCIDM}(Matriz\& \textit{adyacencia}, unsigned int \textit{i}, vector$<$unsigned int$>$\& \textit{conjNodos}, vector$<$unsigned int$>$\& \textit{optimo})\{ 
\newline

\If{(conjNodos.esIndependienteMaximal())}{
		optimo $\longleftarrow$ conjNodos;\\
		\textbf{return} optimo.size();
}
\If{(i.estaEnRango())}{
	\If{(conjNodos es m\'as grande que el optimo actual)}{
		\textbf{return} 0;
	}
	siNoAgrego $\longleftarrow$ calcularCIDM(adyacencia, i+1, conjNodos, optimo);\\
	agrego el nodo $i$ a conjNodos;\\
	siAgrego $\longleftarrow$ calcularCIDM(adyacencia, i+1, conjNodos, optimo);\\
	elimino el nodo $i$ de conjNodos;\\
	\textbf{return} el mejor entre $siNoAgrego$ y $siAgrego$;
}
\textbf{return} 0;
\end{algorithm}

\subsection{Complejidad Temporal}
%Calcular el orden de complejidad temporal de peor caso del algoritmo.
\subsection{Experimentaci\'on}
%Realizar una experimentacion que permita observar los tiempos de ejecucion del algoritmo en funcion de los parametros de la entrada y de las podas y/o estrategias implementadas.
