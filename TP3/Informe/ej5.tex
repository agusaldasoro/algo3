\section{Metaheur\'istica GRASP}
\subsection{Explicaci\'on}

%Explicar detalladamente el algoritmo implementado. Plantear distintos criterios de parada y de seleccion de la lista de candidatos (RCL) de la heurıstica golosa aleatorizada.

La metaheur\'istica \emph{Greedy Randomized Adaptive Search Procedure} (\textbf{GRASP}), es una mezcla de las dos heur\'isticas previas (vistas en \ref{ej3} y \ref{ej4}). Dicho de manera simple: genera un punto de partida de forma golosa para el algoritmo de b\'usqueda local.\\

La distinci\'on de este algoritmo radica en cómo se construye ``\textit{golosamente}'' la soluci\'on inicial.\\

Como la sigla lo indica, consiste en un algoritmo \textit{Goloso Randomnizado}. Es decir que se escogen candidatos a soluci\'on inicial de una manera golosa ligeramente distinta a la ultilizada en la sección anterior. El método \emph{Greedy} de la sección \ref{ej3} escoge a los nodos que van a pertenecer al conjunto solución, de a uno siempre eligiendo al que tiene mayor grado. En cambio, en este caso por cada paso no se elige al nodo de mayor grado sino que se elige uno al azar entre los que ``mejor grado'' tienen.\\ 

Hablar de ``mejor grado'' nos obliga a dar un criterio  para ello, lo que da pie a la definici\'on de la \emph{Restricted Candidate List} (\textbf{RCL}), que es el conjunto de candidatos elegibles para la soluci\'on base.\\

La \emph{\textbf{solución inicial}} se puede formar de diversas maneras. En todos los casos, se añade de a un nodo al conjunto solución hasta que se forme una solución válida. Tres formas para determinar la elección por nodo son: 

\begin{itemize}

\item Elegir un nodo entre los $alpha\%$ nodos que tengan mayor grado hasta completar una soluci\'on v\'alida.

\item Elegir un nodo entre los $alpha$ nodos que tengan mayor grado hasta completar una soluci\'on v\'alida.

\item Elegir un nodo entre los nodos que cumplan determinada propiedad en un $alpha\%$ hasta completar una soluci\'on v\'alida (como por ej: ``Los nodos que tengan grado, a lo sumo, $alpha\%$ menor que el nodo de mayor grado'').

\end{itemize}

Optamos por implementar las primeras dos opciones para generar una solución inicial. Una vez obtenida la solución inicial bajo el método deseado, se aplica el algoritmo de \emph{b\'usqueda local} explicado en el inciso \ref{ej4} sin modificaciones.\\

Un aspecto tambi\'en diferencial de esta heur\'istica, es que no generamos una \'unica instancia inicial, sino que se toma una determinada cantidad de ellas (acorde al criterio de parada). Se ejecuta el algoritmo para la primer instancia y se guarda la solución como \texttt{\'optima}, luego si en alguna ejecución futura se mejora (se obtiene otra solución con menor cantidad de nodos) se actualiza \texttt{\'optima}.\\

Las \emph{\textbf{vecindades}} utilizadas son las mismas que se utilizaron en la heur\'isitca de b\'usqueda local (\ref{ej4}).\\

El \emph{\textbf{criterio de parada}} que adoptamos fue contabilizar las ejecuciones que no produjeron mejora, de modo que sólo se ejecute una determinada cantidad de repeticiones ``malas''. Es decir, siempre que la ejecución otorgue una solución óptima con menos cantidad de nodos que la existente, se seguirá ejecutando. Pero si las ejecuciones no otorgan mejoras se suman al contador, de modo que al llegar a la cantidad indicada se terminará la ejecución.

Otra opci\'on podr\'ia haber sido correr un n\'umero fijo de veces y quedarnos con la mejor soluci\'on encontrada; o tambi\'en si conocieramos alguna cota, acercarnos a esta en un determinado porcentaje; o bien una combinaci\'on de todas.


\newpage
\subsection{Experimentaci\'on}

Para analizar que combinaci\'on de vecindades de b\'usqueda local y elecci\'on de soluci\'on inicial, se acercan a encontrar el \'optimo en distintos escenarios, se experiment\'o con una serie de grafos seg\'un criterios:
\begin{itemize}
	\item Mantener los ejes fijos, variando la cantidad de nodos
	\item Mantener los nodos fijos, variando la cantidad de ejes
	\item Grafos Tablero (an\'alogos a los del ''Se\~nor de los Caballos'')
\end{itemize}

Lo que realizamos fue obtener un promedio de la cantidad de nodos que requer\'ia la soluci\'on \'optima en cada ejecuci\'on del algoritmo. Luego, sabiendo cu\'antos hacen falta por el algoritmo exacto, divimos y obtuvimos en qu\'e porcentaje la heur\'istica falla en encontrar el \'optimo verdadero.\\

La siguiente tabla muestra los valores obtenidos, las columnas 2, 3 y 4 indican el criterio aplicado al grafo.\\

Vecindad 2x1 indica que la vecindad usada fue la de quitar dos nodos y agregar uno, vecindad 3x1 quitar tres y agregar uno.\\

N representa el alfa elegido.\\

N mejores indica que como criterio de b\'usqueda de soluci\'on inicial, se tom\'o uno entre los N mejores seg\'un el criterio greedy establecido, N\% mejores indica seleccionar uno entre los que pertenezcan al N\% de los mejores\\

La diferencia en las dos tablas radica en el criterio de parada, para la primera, se tom\'o la decisi\'on de no seguir buscando si no se modific\'o el \'optimo luego de 5 iteraciones, para la segunda, si no se lo modific\'o luego de 10.\\

\begin{table}[h!]
	\begin{tabular}[c]{|l|l|l|l|}
	\hline  & Ejes Fijos & Nodos Fijos & Tableros \\
	\hline Vecindad 2x1 3 mejores & 0.0706349206 & 0.1209055759 & 0.3333333333 \\
	\hline Vecindad 2x1 5 mejores & 0.0895743146 & 0.1270116294 & 0.125 \\
	\hline Vecindad 2x1 7 mejores & 0.1195959596 & 0.137305459 & 0.5333333333 \\
	\hline Vecindad 2x1 10 mejores & 0.1071500722 & 0.1220588458 & 0.6583333333 \\
	\hline Vecindad 2x1 12 mejores & 0.1856132756 & 0.0979182496 & 0.6583333333 \\
	\hline Vecindad 3x1 3 mejores & 0.218488456 & 0.1334987987 & 0.55 \\
	\hline Vecindad 3x1 5 mejores & 0.2886399711 & 0.1589123677 & 0.2916666667 \\
	\hline Vecindad 3x1 7 mejores & 0.2561724387 & 0.2224135112 & 0.7333333333 \\
	\hline Vecindad 3x1 10 mejores & 0.2550937951 & 0.2245729711 & 0.9416666667 \\
	\hline Vecindad 3x1 12 mejores & 0.2745815296 & 0.2259357556 & 0.9416666667 \\
	\hline Vecindad 2x1 10\% mejores & 0.0706349206 & 0.0957461757 & 0.125 \\
	\hline Vecindad 2x1 25\% mejores & 0.0672438672 & 0.1098904806 & 0.9916666667 \\
	\hline Vecindad 2x1 50\% mejores & 0.1260894661 & 0.1237291042 & 0.325 \\
	\hline Vecindad 2x1 75\% mejores & 0.3068614719 & 0.0978193541 & 0.35 \\
	\hline Vecindad 2x1 100\% mejores & 0.2456349206 & 0.1207595377 & 0.8333333333 \\
	\hline Vecindad 3x1 10\% mejores & 0.1113455988 & 0.1737028679 & 0.1666666667 \\
	\hline Vecindad 3x1 25\% mejores & 0.1935064935 & 0.1672620534 & 0.4833333333 \\
	\hline Vecindad 3x1 50\% mejores & 0.2420526696 & 0.1807902717 & 0.35 \\
	\hline Vecindad 3x1 75\% mejores & 0.3499422799 & 0.2287379706 & 0.4833333333 \\
	\hline Vecindad 3x1 100\% mejores & 0.262049062 & 0.240385845 & 0.8583333333 \\
	\hline
	\end{tabular}
\caption{Promedio de porcentajes de error de GRASP con respecto al algoritmo exacto para cada vecindad y cada selecci\'on de soluci\'on inicial. Con criterio de parada fijado en 5 repeticiones sin mejorar la mejor soluci\'on hallada}
\end{table}
 
\begin{table}[h!]
	\begin{tabular}[c]{|l|l|l|l|}
	\hline  & Ejes Fijos & Nodos Fijos & Tableros \\
	\hline Vecindad 2x1 3 mejores & 0.1444444444 & 0.0970751665 & 0 \\
	\hline Vecindad 2x1 5 mejores & 0.0623015873 & 0.0818842512 & 0.4166666667 \\
	\hline Vecindad 2x1 7 mejores & 0.1297510823 & 0.0979054066 & 0 \\
	\hline Vecindad 2x1 10 mejores & 0.2647799423 & 0.1184019209 & 0.4166666667 \\
	\hline Vecindad 2x1 12 mejores & 0.1652128427 & 0.1197314734 & 0.7 \\
	\hline Vecindad 3x1 3 mejores & 0.2100324675 & 0.1881385561 & 0 \\
	\hline Vecindad 3x1 5 mejores & 0.2343542569 & 0.2078457808 & 0.6333333333 \\
	\hline Vecindad 3x1 7 mejores & 0.3034018759 & 0.2769039011 & 0 \\
	\hline Vecindad 3x1 10 mejores & 0.3261291486 & 0.2172843582 & 0.55 \\
	\hline Vecindad 3x1 12 mejores & 0.2863239538 & 0.2270750463 & 0.4833333333 \\
	\hline Vecindad 2x1 10\% mejores  & 0.0944444444 & 0.0672958833 & 0 \\
	\hline Vecindad 2x1 25\% mejores & 0.0765873016 & 0.1072437596 & 0.1666666667 \\
	\hline Vecindad 2x1 50\% mejores & 0.1878246753 & 0.1158854895 & 0 \\
	\hline Vecindad 2x1 75\% mejores & 0.1126262626 & 0.0926548434 & 0.5416666667 \\
	\hline Vecindad 2x1 100\% mejores & 0.1781024531 & 0.1162941871 & 0.45 \\
	\hline Vecindad 3x1 10\% mejores  & 0.1523268398 & 0.2101337874 & 0 \\
	\hline Vecindad 3x1 25\% mejores & 0.1327561328 & 0.2044939959 & 0.1666666667 \\
	\hline Vecindad 3x1 50\% mejores & 0.25 & 0.2308454751 & 0.25 \\
	\hline Vecindad 3x1 75\% mejores & 0.2540656566 & 0.209238541 & 0.6666666667 \\
	\hline Vecindad 3x1 100\% mejores & 0.2406024531 & 0.2213013582 & 0.4916666667 \\
	\hline
	\end{tabular}
\caption{Promedio de porcentajes de error de GRASP con respecto al algoritmo exacto para cada vecindad y cada selecci\'on de soluci\'on inicial. Con criterio de parada fijado en 10 repeticiones sin mejorar la mejor soluci\'on hallada}
\end{table}

\newpage

Para seleccionar la mejor combinaci\'on de par\'ametros de la heur\'istica, respecto a la soluci\'on encontrada contra la \'optima del algoritmo exacto, tomamos como criterio que se minimice la suma de cada fila, es decir, que para casos donde los grafos incrementan su cantidad de ejes, o bien solo su cantidad de nodos, y tableros de caballos, la diferencia contra la \'optima sea m\'inima.\\

Esto nos lleva a que la combinaci\'on \'optima es: Vecindad 2x1 10\% mejores con 10 iteraciones consecutivas sin ver modificaciones en el \'optimo hallado hasta ese momento. Con un error promedio del 5,3\%.


%Realizar una experimentacion que permita observar los tiempos de ejecucion y la calidad de las soluciones obtenidas. Se debe experimentar variando los valores de los parametros de la metaheurıstica (lista de candidatos, criterios de parada, etc.) y las vecindades utilizadas en la busqueda local. Elegir, si es posible, la configuracion que mejores resultados provea para el grupo de instancias utilizado.
