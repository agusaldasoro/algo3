\section{Problema 2: Alta Frecuencia}
\subsection{Descripci\'on de la problem\'atica}

Se quiere transmitir informaci\'on secuencialmente mediante un enlace el mayor tiempo posible. Los enlaces tienen asociadas distintas frecuencias, con un costo por minuto y un intervalo de tiempo (sin cortes) en el cual funcionan. Se utilizan durante minutos enteros, y es posible cambiar de una frecuencia a otra instant\'anemente (del minuto 1 al 4 uso la frecuencia A y del 4 al 6 la B). Los datos del precio y e intervalo de tiempo de cada frecuencia son dados. Se desea optimizar este problema para transmitir todo el tiempo que tenga al menos una frecuencia abierta, pero gastando la menor cantidad de dinero. Se debe contar con una complejidad de $O(n.log(n))$.\\

A continuaci\'on se muestran dos casos particulares de este problema. En ambos se ofrecen tres frecuencias, con distintos costos cada una. Se puede ver recuadrado en violeta cu\'al es la elecci\'on que debe hacerse por intervalo de tiempo.


 \begin{figure}[h!]
   \begin{center}
 	\includegraphics[scale=0.45]{imagenes/ej2/ejemplo1.png}
 	\caption{Ejemplo 1}
% 	\label{caballito}	
   \end{center}
 \end{figure}

 \begin{figure}[h!]
   \begin{center}
 	\includegraphics[scale=0.45]{imagenes/ej2/ejemplo2.png}
 	\caption{Ejemplo 2}
% 	\label{caballito}	
   \end{center}
 \end{figure}


\newpage

\subsection{Resoluci\'on propuesta y justificaci\'on}

El algoritmo que utilizamos pertenece a la familia de \emph{Divide \& Conquer}.\\

\textcolor{red}{Aca pasa lo mismo de la implementacion porque hablamos mucho de vector y bla...}\\

El primer paso consiste en ordenar las frecuencias de menor a mayor en base al costo de cada una.\\

Luego, se sigue el esquema cl\'asico de Divide \& Conquer:\\

	\begin{codesnippet}
	\begin{verbatim}
divide(conjuntoDeFrecuencias F){
    Si hay mas de un elemento:
        Divido F en mitades A, B.
        intervalosA = divide(A)
        intervalosB = divide(B)
        Devuelvo conquer(intervalosA, intervalosB)
    Si hay un solo elemento:
        Lo devuelvo.	
}
	\end{verbatim}
	\end{codesnippet}

En palabras, si hay una sola frecuencia, la devolvemos, pues es trivial que su intervalo de duraci\'on es el m\'as barato y el de mayor extensi\'on temporal.\\

Si no, intervalosA ser\'a el conjunto de intervalos en la que funcionar\'a cada frecuencia, de modo que el costo de contratar el servicio con este cronograma sea m\'inimo en el costo y m\'aximo en la cantidad de tiempo de uso. E intervalosB ser\'a un conjunto con las mismas carater\'isticas, con la diferencia de que el A ser\'a el m\'as \'optimo de la mitad m\'as barata y el B el m\'as \'optimo de la mitad m\'as cara. Esto resulta de haber ordenado las frecuencias por su costo antes de comenzas con este tramo de algoritmo.\textcolor{red}{No se si este parrafo se entiende mucho}\\

Al hacer conquer(intervalosA, intervalosB) se obtiene el conjunto de intervalos con las caracter\'isticas mencionadas pero de todas las frecuencias.\textcolor{red}{No habria que explicar mas aca?}\\

%Nuestro algoritmo de Merge (\emph{conquer}) se encarga de elegir entre las frecuencias de dos arreglos pasados como parámetro, de modo que devuelve un sólo vector indicando los intervalos ocupados por las frecuencias elegidas. 

%Dado el enunciado del problema, para elegir qu\'e frecuencia utilizar en determinado intervalo de tiempo se debe priorizar el precio m\'as barato emitiendo se\~nal siempre que sea posible.\\

%Gracias a que en el primer llamado de nuestra funci\'on estas se encontraban en orden creciente respecto del costo, en cada paso de \emph{conquer} de los dos arreglos de entrada con intervalos se van a priorizar los de la izquierda. Es decir que en cada paso, todos los intervalos pertenecientes al vector de la izquierda (como son los de menor precio) van a pertencer al vector resultado. Mientras que s\'olo los intervalos que completen tiempo sin se\~nal pertenecientes al vector de la derecha van a ser colocados en el vector resultado. Esto representa un invariante que se va a cumplir en cada paso del algoritmo, lo cual nos permite justificar que la soluci\'on obtenida es la deseada. \textcolor{red}{Que alguien lea esto para ver si se entiende, para mi si :)}\\

%	\begin{codesnippet}
%	\begin{verbatim}
%conquer(conjuntoDeFrecuencias A, conjuntoDeFrecuencias B){
%	vector<frecuencia>::iterator iterCara = cara.begin(), iterBarata = barata.begin();
%	vector<frecuencia> res;
%	
%	En el conjunto res voy a tener el resultado.
%    Voy recorriendo en orden A y B, mientras haya elementos en A:
%    //Llamo A[i] al intervalo actual de A y B[j] al de B.
%        Si B[j] comienza antes que A[i]:
%            Si B[j] termina antes que A[i]:
%                Inserto B[j] en res.
%                j++
%            Si B[j] termina despues que A[i] empiece                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              :
%                
%    
%    
%        Si A[i] comienza antes que B[j]:
%            Inserto A[i] en res
%            Si B[j] se superpone en algun momento con A[i]:
%                Al comienzo de B[j] le asigno el final de A[i]
%
%
%
%
%	while(iterCara != cara.end()){
%		if(iterBarata != barata.end()){
%			if(iterCara->principio < iterBarata->principio){ //la cara empieza antes
%				if(iterCara->fin <= iterBarata->principio){ //la cara termina antes de que empiece la barata
%					res.push_back(*iterCara);				//meto la cara entera
%					iterCara++;
%				}
%				else{ //la cara empieza antes y termina despues del principio de la barata
%					frecuencia antes;
%					antes.id = iterCara->id;
%					antes.costo = iterCara->costo;
%					antes.principio = iterCara->principio;
%					antes.fin = iterBarata->principio;
%					res.push_back(antes);
%					iterCara->principio = iterBarata->fin;
%				}
%			}
%			else{ //la barata empieza antes (o igual) que la cara
%				if(iterCara->fin > iterBarata->fin){ //la cara termina despues que la barata
%					if (iterCara->principio < iterBarata->fin) //este if es nuevo
%						iterCara->principio = iterBarata->fin;
%					res.push_back(*iterBarata);
%					iterBarata++;
%				}
%				else
%					iterCara++;
%			}
%		}
%		else{
%			if(iterCara->principio < iterCara->fin)
%				res.push_back(*iterCara);
%			iterCara++;
%		}
%	}
%	while(iterBarata != barata.end()){
%		res.push_back(*iterBarata);
%		iterBarata++;
%	}
%	return res;
%}
%
%	\end{verbatim}
%	\end{codesnippet}

Este \'ultimo paso abusa del invariante: todos los intervalos del conjunto intervalosA deben aparecer en el conjunto soluci\'on, y que lo \'unico que debe agregar son los intervalos de intervalosB que o bien aumentan el rango de tiempo para transmitir (uso el servicio desde antes o m\'as tiempo) o bien completan gaps que puedan existir entre las frecuencias m\'as baratas.

%Este algoritmo resuelve lo propuesto dando una soluci\'on \'optima porque del modo en que est\'a definido, primero divide al grupo con todas las frecuencias ofrecidas recursivamente hasta llegar a conjuntos con una sola frecuencia. Luego, al momento de mergear estos grupos de a dos, siempre prioriza al grupo de la izquierda (el m\'as barato). 

%Esto quiere decir que en el primer paso de este \textit{merge} se van a comparar solamente dos frecuencias entre s\'i, colocando la frecuencia m\'as barata completa y; si la oferta de intervalos de la frecuencia m\'as cara completa uno o dos intervalos donde no se le hab\'ia asignado se\~nal, se le otorga a ellos la frecuencia m\'as cara. De este modo, comparamos de a dos, frecuencias consecutivas otorg\'andole prioridad a la frecuencia m\'as barata. \textcolor{red}{Poner dibujito.} 

%En el siguiente paso del \textit{merge} se van a comparar dos conjuntos de intervalos con dos frecuencias en cada uno. Cada uno de estos conjuntos puede estar conformado por uno, dos o tres intervalos. \textcolor{red}{Poner dibujito} Gracias al formato de nuestro algoritmo, en cada paso del merge se preserva el invariante de que el conjunto ubicado a la izquierda tiene las frecuencias m\'as baratas mientras que el de la derecha tiene las m\'as caras. Se prosigue de manera an\'aloga a lo anterior, se preservan todos los intervalos de frecuencias pertenecientes al conjunto de los m\'as baratos y s\'olo se agregan frecuencias del conjunto caro en caso de que esten disponibles en intervalos de tiempos que hayan quedado vac\'ios.

%Estos pasos se van a reiterar, comparando conjuntos de intervalos entre dos, hasta que se hayan recorrido todas las frecuencias.\\

%Una vez terminados todos los pasos recursivos, vamos a contar con el conjunto de intervalos que completen la mayor cantidad de tiempo con el costo m\'as bajo. Si no hay dos frecuencias con el mismo costo, esta soluci\'on (\'optima) es \'unica, en caso contrario podr\'ia existir m\'as de una soluci\'on \'optima. \\

\newpage

\subsection{An\'alisis de la complejidad}

Para realizar este análisis primero es necesario calcular cu\'antos intervalos contendr\'a, como m\'aximo, el conjunto soluci\'on (desde ahora ``\emph{CS}''). Este valor ser\'a $2n-1$, siendo $n$ la cantidad de frecuencias dadas como par\'ametro.

Esto se deduce de analizar las posibles entradas para el algoritmo. Primero vamos a analizar el caso donde no existan dos frecuencias pasadas como par\'ametro con el mismo valor. De este modo la soluci\'on \'optima al problema va a ser \'unica. \\


Supongamos \textbf{n=1}. El intervalo de la frecuencia pasada como par\'ametro ser\'a el \'unico elemento del \emph{CS} y verifica $2n-1$ $=$ $2$.$1-1$ $=$ $1$.\\

Luego, tomamos \textbf{n=2}. De este modo, ambas pueden solaparse o ser disjuntas. Llamamos $1$ a la frecuencia m\'as barata y $2$ a la m\'as cara, $1$ va a estar incluida completa en \emph{CS} y $2$ puede formar dos intervalos, uno o ninguno. A continuaci\'on, se adjuntan cada uno de los casos, indicando en naranja los intervalos que pertenecer\'an a \emph{CS}.\\

La frecuencia $2$ no forma ning\'un intervalo:

 \begin{figure}[h!]
   \begin{center}
 	\includegraphics[scale=0.45]{imagenes/ej2/secuencias/Paso1/Caso0.png}
% 	\caption{}
% 	\label{caballito}	
   \end{center}
 \end{figure}

La frecuencia $2$ forma un intervalo:

 \begin{figure}[h!]
   \begin{center}
 	\includegraphics[scale=0.45]{imagenes/ej2/secuencias/Paso1/Caso1.png}
% 	\caption{}
% 	\label{caballito}	
   \end{center}
 \end{figure}
 

 
La frecuencia $2$ forma dos intervalos: 
 
  \begin{figure}[h!]
   \begin{center}
 	\includegraphics[scale=0.45]{imagenes/ej2/secuencias/Paso1/Caso2.png}
% 	\caption{}
% 	\label{caballito}	
   \end{center}
 \end{figure}
 

\newpage 

Es decir, para n=2 la cantidad m\'axima de intervalos posibles es $3$ intervalos, lo cual tambi\'en cumple $2n-1$ $=$ $2$.$2-1$ $=$ $3$.\\
 
%, entonces dado una frecuencia (la m\'as barata), la otra (m\'as cara) puede que se solape o no. Si no lo hace, entonces el CS tendr\'a ambos intervalos incluidos. Si se solapa, 1) est\'a inclu \'ido, con lo cual el CS ser\'a contendr\'a solo a la primer frecuencia; 2) arranca o termina mientras la otra est\'a disponible, dejando al CS con \'unicamente el pedazo de intervalo que no se solapa y el otro entero; o bien 3) arranca y termina antes y despu\'es de que arranque y termina el primero, logrando que el CS tenga un primer intervalo de la segunda frecuencia, hasta que arranca la primera, que entra por completo y luego un segundo intervalo de la segunda frecuencia que empieza cuando termina la primera. Esto se extiende para todo n con los mismos resultados, solo que puede agregarse un 4) completar un gap.\\

Al momento de tomar \textbf{n=3}, lo hacemos considerando las frecuencias $1$, $2$ y $3$. Partimos del caso anterior al que le a\~nadimos la frecuencia $3$. Es decir, vamos a contar con a lo sumo $3$ intervalos. La distribuci\'on de los intervalos se va a dar de la siguiente manera:\\

  \begin{figure}[h!]
   \begin{center}
 	\includegraphics[scale=0.45]{imagenes/ej2/secuencias/salida2.png}
% 	\caption{}
% 	\label{caballito}	
   \end{center}
 \end{figure}

Podemos observar que de las cuatro distribuciones distintas que pueden ocurrir, en s\'olo una los intervalos son completamente disjuntos, esto es en el caso donde se a\~nadi\'o el intervalo $2$ completo. En los dem\'as casos, si bien pueden ser uno, dos o tres intervalos distintos al unirlos conforman un intervalo continuo, por lo cual entre ellos no va a haber gaps, es decir s\'olo se podr\'an a\~nadir intervalos en los bordes. Por este motivo, a estos casos los tomamos an\'alogos al caso de $n=2$ donde se agregar\'an a lo sumo dos intervalos, lo cual conforma en el caso m\'aximo 3 intervalos pre-existentes y 2 nuevos, dando un total de 5. Esto cumple lo planteado $2n-1$ $=$ $2$.$3-1$ $=$ $5$.\\

Ahora debemos considerar por separado, el caso donde contamos con dos intervalos pre-existentes totalmente disjuntos.\\

El \'unico caso donde se adicionan tres intervalos es el siguiente:\\
  \begin{figure}[h!]
   \begin{center}
 	\includegraphics[scale=0.45]{imagenes/ej2/secuencias/Paso2/Caso3.png}
% 	\caption{}
% 	\label{caballito}	
   \end{center}
 \end{figure}
\newpage

Los casos donde se adicionan dos intervalos son los mostrados a continuaci\'on:
  \begin{figure}[h!]
   \begin{center}
 	\includegraphics[scale=0.45]{imagenes/ej2/secuencias/Paso2/todos2.png}
% 	\caption{}
% 	\label{caballito}	
   \end{center}
 \end{figure}


Los siguientes son los casos donde al agregar la frecuencia $3$ s\'olo se adiciona un intervalo:
  \begin{figure}[h!]
   \begin{center}
 	\includegraphics[scale=0.2]{imagenes/ej2/secuencias/Paso2/todos1.png}
% 	\caption{}
% 	\label{caballito}	
   \end{center}
 \end{figure}

Por consiguiente, el m\'aximo de intervalos que se pueden a\~nadirse son tres, considerando siempre s\'olo dos pre-existentes, lo cual da un total de 5 que cumple: $2n-1$ $=$ $2$.$3-1$ $=$ $5$.\\

%Hasta el caso 3) se ve claramente que el m\'aximo n\'umero de intervalos es el propuesto (agregar un intervalo a izquierda y uno a derecha). Para el caso 4) hay que tener en cuenta que el paso anterior fue un caso de no solapamiento, es decir que si intercambiara la frecuencia que completa gaps con la no solapada, entonces entrar\'ia en el caso 2) o en el caso 3), verificando que a lo sumo se llega a \emph{2n-1} intervalos.\\

\textcolor{red}{Extender la validez a n!!}\\


Partimos de la hip\'otesis de que los costos de las frecuencias eran todos distintos, lo cual nos asegura una soluci\'on \'unica con una cantidad \'unica de intervalos. Ahora, si consideramos que pueden existir dos (o m\'as) frecuencias, llamemos \emph{A} y \emph{B}, con el mismo precio podemos asumir indistintamente que \emph{A$<$B} o \emph{A$>$B} lo cual podr\'ia devolver intervalos distintos, pero siempre su cantidad va a estar acotada por lo mismo probado anteriormente: $2n-1$.\\

Una vez que ya acotamos la cantidad final de intervalos por $2n-1$, podemos proceder al an\'alisis de complejidad del algoritmo de Divide \& Conquer.

El algoritmo divide tiene complejidad \emph{T(n)=2T(n/2)+O(conquer)}. Donde conquer va a recorrer, en el peor caso, dos vectores cuyas longitudes suman n, y aplicar operaciones que toman $O(1)$ para cada una de ellas. El vector que va construyendo con el CS tambi\'en toma $O(n)$. Estas complejidades se suman y por propiedades de O se obtiene $O(n)$.\\

Reemplazando en la ecuaci\'on, \emph{T(n)=2T(n/2)+O(n)} que es la misma ecuaci\'on de recurrencia que MergeSort, que por Teorema Maestro se deduce que tiene complejidad $O(n.log(n))$, como pretend\'iamos.

\newpage
\subsection{C\'odigo fuente}
\newpage
\subsection{Experimentaci\'on}

\subsubsection*{Constrastaci\'on Emp\'irica de la complejidad}

