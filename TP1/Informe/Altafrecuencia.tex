\section{Problema 2: Alta Frecuencia}
\subsection{Descripci\'on de la problem\'atica}

Se quiere transmitir informaci\'on secuencialmente mediante un enlace el mayor tiempo posible. Los enlaces tienen asociadas distintas frecuencias, con un costo por minuto y un intervalo de tiempo (sin cortes) en el cual funcionan. Se utilizan durante minutos enteros, y es posible cambiar de una frecuencia a otra instant\'anemente (del minuto 1 al 4 uso la frecuencia A y del 4 al 6 la B). Los datos del precio y e intervalo de tiempo de cada frecuencia son dados. Se desea optimizar este problema para transmitir todo el tiempo que tenga al menos una frecuencia abierta, pero gastando la menor cantidad de dinero. Se debe contar con una complejidad de $O(n.log(n))$.\\

A continuaci\'on se muestran dos casos particulares de este problema. En ambos se ofrecen tres frecuencias, con distintos costos cada una. Se puede ver recuadrado en violeta cu\'al es la elecci\'on que debe hacerse por intervalo de tiempo.


 \begin{figure}[h!]
   \begin{center}
 	\includegraphics[scale=0.45]{imagenes/ej2/ejemplo1.png}
 	\caption{Ejemplo 1}
% 	\label{caballito}	
   \end{center}
 \end{figure}

 \begin{figure}[h!]
   \begin{center}
 	\includegraphics[scale=0.45]{imagenes/ej2/ejemplo2.png}
 	\caption{Ejemplo 2}
% 	\label{caballito}	
   \end{center}
 \end{figure}


\newpage

\subsection{Resoluci\'on propuesta y justificaci\'on}

El algoritmo que utilizamos pertenece a la familia de \emph{Divide \& Conquer}.\\

\textcolor{red}{Aca pasa lo mismo de la implementacion porque hablamos mucho de vector y bla...}\\

El primer paso consiste en ordenar las frecuencias de menor a mayor en base al costo de cada una.\\

Luego, se sigue el esquema cl\'asico de Divide \& Conquer:\\

	\begin{codesnippet}
	\begin{verbatim}
divide(conjuntoDeFrecuencias F){
    Si hay mas de un elemento:
        Divido F en mitades A, B.
        intervalosA = divide(A)
        intervalosB = divide(B)
        Devuelvo conquer(intervalosA, intervalosB)
    Si hay un solo elemento:
        Lo devuelvo.	
}
	\end{verbatim}
	\end{codesnippet}

En palabras, si hay una sola frecuencia, la devolvemos, pues es trivial que su intervalo de duraci\'on es el m\'as barato y el de mayor extensi\'on temporal.\\

Si no, intervalosA ser\'a el conjunto de intervalos en la que funcionar\'a cada frecuencia, de modo que el costo de contratar el servicio con este cronograma sea m\'inimo en el costo y m\'aximo en la cantidad de tiempo de uso. E intervalosB ser\'a un conjunto con las mismas carater\'isticas, con la diferencia de que el A ser\'a el m\'as \'optimo de la mitad m\'as barata y el B el m\'as \'optimo de la mitad m\'as cara. Esto resulta de haber ordenado las frecuencias por su costo antes de comenzas con este tramo de algoritmo.

Al hacer conquer(intervalosA, intervalosB) se obtiene el conjunto de intervalos con las caracter\'isticas mencionadas pero de todas las frecuencias.\\

%Nuestro algoritmo de Merge (\emph{conquer}) se encarga de elegir entre las frecuencias de dos arreglos pasados como parámetro, de modo que devuelve un sólo vector indicando los intervalos ocupados por las frecuencias elegidas. 

%Dado el enunciado del problema, para elegir qu\'e frecuencia utilizar en determinado intervalo de tiempo se debe priorizar el precio m\'as barato emitiendo se\~nal siempre que sea posible.\\

%Gracias a que en el primer llamado de nuestra funci\'on estas se encontraban en orden creciente respecto del costo, en cada paso de \emph{conquer} de los dos arreglos de entrada con intervalos se van a priorizar los de la izquierda. Es decir que en cada paso, todos los intervalos pertenecientes al vector de la izquierda (como son los de menor precio) van a pertencer al vector resultado. Mientras que s\'olo los intervalos que completen tiempo sin se\~nal pertenecientes al vector de la derecha van a ser colocados en el vector resultado. Esto representa un invariante que se va a cumplir en cada paso del algoritmo, lo cual nos permite justificar que la soluci\'on obtenida es la deseada. \textcolor{red}{Que alguien lea esto para ver si se entiende, para mi si :)}\\

%	\begin{codesnippet}
%	\begin{verbatim}
%conquer(conjuntoDeFrecuencias A, conjuntoDeFrecuencias B){
%	vector<frecuencia>::iterator iterCara = cara.begin(), iterBarata = barata.begin();
%	vector<frecuencia> res;
%	
%	En el conjunto res voy a tener el resultado.
%    Voy recorriendo en orden A y B, mientras haya elementos en A:
%    //Llamo A[i] al intervalo actual de A y B[j] al de B.
%        Si B[j] comienza antes que A[i]:
%            Si B[j] termina antes que A[i]:
%                Inserto B[j] en res.
%                j++
%            Si B[j] termina despues que A[i] empiece                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              :
%                
%    
%    
%        Si A[i] comienza antes que B[j]:
%            Inserto A[i] en res
%            Si B[j] se superpone en algun momento con A[i]:
%                Al comienzo de B[j] le asigno el final de A[i]
%
%
%
%
%	while(iterCara != cara.end()){
%		if(iterBarata != barata.end()){
%			if(iterCara->principio < iterBarata->principio){ //la cara empieza antes
%				if(iterCara->fin <= iterBarata->principio){ //la cara termina antes de que empiece la barata
%					res.push_back(*iterCara);				//meto la cara entera
%					iterCara++;
%				}
%				else{ //la cara empieza antes y termina despues del principio de la barata
%					frecuencia antes;
%					antes.id = iterCara->id;
%					antes.costo = iterCara->costo;
%					antes.principio = iterCara->principio;
%					antes.fin = iterBarata->principio;
%					res.push_back(antes);
%					iterCara->principio = iterBarata->fin;
%				}
%			}
%			else{ //la barata empieza antes (o igual) que la cara
%				if(iterCara->fin > iterBarata->fin){ //la cara termina despues que la barata
%					if (iterCara->principio < iterBarata->fin) //este if es nuevo
%						iterCara->principio = iterBarata->fin;
%					res.push_back(*iterBarata);
%					iterBarata++;
%				}
%				else
%					iterCara++;
%			}
%		}
%		else{
%			if(iterCara->principio < iterCara->fin)
%				res.push_back(*iterCara);
%			iterCara++;
%		}
%	}
%	while(iterBarata != barata.end()){
%		res.push_back(*iterBarata);
%		iterBarata++;
%	}
%	return res;
%}
%
%	\end{verbatim}
%	\end{codesnippet}

Este \'ultimo paso abusa del invariante: todos los intervalos del conjunto intervalosA deben aparecer en el conjunto soluci\'on, y que lo \'unico que debe agregar son los intervalos de intervalosB que o bien aumentan el rango de tiempo para transmitir (uso el servicio desde antes o m\'as tiempo) o bien completan gaps que puedan existir entre las frecuencias m\'as baratas.

%Este algoritmo resuelve lo propuesto dando una soluci\'on \'optima porque del modo en que est\'a definido, primero divide al grupo con todas las frecuencias ofrecidas recursivamente hasta llegar a conjuntos con una sola frecuencia. Luego, al momento de mergear estos grupos de a dos, siempre prioriza al grupo de la izquierda (el m\'as barato). 

%Esto quiere decir que en el primer paso de este \textit{merge} se van a comparar solamente dos frecuencias entre s\'i, colocando la frecuencia m\'as barata completa y; si la oferta de intervalos de la frecuencia m\'as cara completa uno o dos intervalos donde no se le hab\'ia asignado se\~nal, se le otorga a ellos la frecuencia m\'as cara. De este modo, comparamos de a dos, frecuencias consecutivas otorg\'andole prioridad a la frecuencia m\'as barata. \textcolor{red}{Poner dibujito.} 

%En el siguiente paso del \textit{merge} se van a comparar dos conjuntos de intervalos con dos frecuencias en cada uno. Cada uno de estos conjuntos puede estar conformado por uno, dos o tres intervalos. \textcolor{red}{Poner dibujito} Gracias al formato de nuestro algoritmo, en cada paso del merge se preserva el invariante de que el conjunto ubicado a la izquierda tiene las frecuencias m\'as baratas mientras que el de la derecha tiene las m\'as caras. Se prosigue de manera an\'aloga a lo anterior, se preservan todos los intervalos de frecuencias pertenecientes al conjunto de los m\'as baratos y s\'olo se agregan frecuencias del conjunto caro en caso de que esten disponibles en intervalos de tiempos que hayan quedado vac\'ios.

%Estos pasos se van a reiterar, comparando conjuntos de intervalos entre dos, hasta que se hayan recorrido todas las frecuencias.\\

%Una vez terminados todos los pasos recursivos, vamos a contar con el conjunto de intervalos que completen la mayor cantidad de tiempo con el costo m\'as bajo. Si no hay dos frecuencias con el mismo costo, esta soluci\'on (\'optima) es \'unica, en caso contrario podr\'ia existir m\'as de una soluci\'on \'optima. \\

\newpage

\subsection{An\'alisis de la complejidad}

Para realizar este análisis primero es necesario calcular cu\'antos intervalos puede llegar a haber en el conjunto soluci\'on (desde ahora 'CS'), este valor es, en el peor caso, \emph{2n-1}, siendo n el n\'umero de frecuencias.\\

Esto se deduce de analizar las posibles entradas para el algoritmo, supongamos n=1. El intervalo de la frecuencia ser\'a el \'unico elemento del CS y verifica $2n-1=2x1-1=1$.\\

Si ahora tomamos n=2, entonces dado una frecuencia (la m\'as barata), la otra (m\'as cara) puede que se solape o no. Si no lo hace, entonces el CS tendr\'a ambos intervalos incluidos. Si se solapa, 1) est\'a inclu \'ido, con lo cual el CS ser\'a contendr\'a solo a la primer frecuencia; 2) arranca o termina mientras la otra est\'a disponible, dejando al CS con \'unicamente el pedazo de intervalo que no se solapa y el otro entero; o bien 3) arranca y termina antes y despu\'es de que arranque y termina el primero, logrando que el CS tenga un primer intervalo de la segunda frecuencia, hasta que arranca la primera, que entra por completo y luego un segundo intervalo de la segunda frecuencia que empieza cuando termina la primera. Esto se extiende para todo n con los mismos resultados, solo que puede agregarse un 4) completar un gap.\\

Hasta el caso 3) se ve claramente que el m\'aximo n\'umero de intervalos es el propuesto (agregar un intervalo a izquierda y uno a derecha). Para el caso 4) hay que tener en cuenta que el paso anterior fue un caso de no solapamiento, es decir que si intercambiara la frecuencia que completa gaps con la no solapada, entonces entrar\'ia en el caso 2) o en el caso 3), verificando que a lo sumo se llega a \emph{2n-1} intervalos.\\

El algoritmo divide tiene complejidad \emph{T(n)=2T(n/2)+O(conquer)}. Donde conquer va a recorrer, en el peor caso, dos vectores cuyas longitudes suman n, y aplicar operaciones que toman $O(1)$ para cada una de ellas. El vector que va construyendo con el CS tambi\'en toma $O(n)$. Estas complejidades se suman y por propiedades de O se obtiene $O(n)$.\\

Reemplazando en la ecuaci\'on, \emph{T(n)=2T(n/2)+O(n)} que es la misma ecuaci\'on de recurrencia que MergeSort, que por Teorema Maestro se deduce que tiene complejidad $O(n.log(n))$, como pretend\'iamos.

\newpage
\subsection{C\'odigo fuente}
\newpage
\subsection{Experimentaci\'on}

\subsubsection{Constrastaci\'on Emp\'irica de la complejidad}
-Comparar tiempos para 10, 100, 1000, 10000 y 100000 intervalos generando aleatoriamente varios de cada una y scar promedio. Hacer lo que hicieron en clase\\


\newpage
\subsubsection{Modificaci\'on del algoritmo}
Debido a que nuestro algoritmo no considera como caso espec\'ifico el ordenar distintas frecuencias con el mismo valor, al momento de elegir intervalos se podr\'ian realizar cortes innecesarios. Es decir, no siempre se elige la cantidad m\'inima posible en estos casos.\\

Como consideramos que esto puede tardar un tiempo no despreciable, modificamos el operador $<$ para frecuencias, de modo que cuando tiene dos frecuencias del mismo valor ingrese primero la que tenga el comienzo antes y, en caso de comenzar en simult\'aneo, ingrese primero la frecuencia de mayor tama\~no.\\

\textcolor{blue}{Buena justificacion! me gusta :)}\\

\textcolor{red}{Aca poner el codigo que se deberia modificar.}\\

\textcolor{red}{Aca va el grafico de esto}\\

\textcolor{red}{Comentar si paso lo que esperabamos o no.}
